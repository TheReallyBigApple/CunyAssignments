---
title: "Data 605: Week 2"
output:
  html_document:
    highlight: pygments
    theme: cerulean
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---


<style type="text/css">
                      .tab { margin-left: 60px; }
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE)
```

<br><br><br>

<br>
<font size="7" color="purple">Transposes and LDU Factorization</font>
<br>
<br><br><br>


## Commutativity of a A and T(A)

<br>


Show that

$$A^T \cdot A \ \neq \ A \cdot A^T$$

<br>

The dot product of 2 matrices is an operation on the <b><i>row</b></i> of operand 1 and the <b><i>column</b></i> of operand 2 
 
<br>

It will be shown that by flipping the operands the values within the respective row and column can change

<br>

This function *decomposes* a dot product position row 1, column 1, shows the values that effect position 1,1,
<br>

This will support the posit that it is not a commutative operation.

<br>


```{r decompose_dot_product}

decompose_dot_product<-function(A,B) {
  
  print("The decomposition of position (1,1) is : ") 
  print(paste("(", A[1,1], " * ", B[1,1], ") +  (", A[1,2], "* ", B[2,1], ") + (", A[1,3], " * ", B[3,1], ")"))

  print("The dot product matrix value in position (1,1) is ") 
  print((A %*% B)[1,1])
  
  # explicitly
  # print((A[1,1] * B[1,1]) + (A[1,2] * B[2,1]) + (A[1,3] * B[3,1]))
}

```


<br>

Here we create matrix A

<br>

$$A \ = \ \begin{bmatrix} 	1&2&3\\ 4&5&6\\ 7&8&9		\end{bmatrix}$$
<br>

```{r matrix_a}

a<-matrix(seq(1,9), byrow = TRUE, ncol = 3)   


```



<br>

Here we create the transpose of T(A).

<br>

$$T(A) \ = \ \begin{bmatrix} 	1&4&7\\ 2&5&8\\ 3&6&9		\end{bmatrix}$$
<br>

```{r matrix_a_transposed}

t_a<-t(a)  

```




<br>

For any 2 Matrices, the dot product result will have a row/column corresponding <b><i>the row of operand 1 and the column of operand 2.</i></b>

<br>

So in this case, row 1 of A (1,2,3) times column 1 of T(A) (1,2,3) = 14



```{r decompose1}

decompose_dot_product(a,t_a)

```



<br>

When the operands are exchanged, the operands are sourced from different values.

<br>
Now row 1 of T(A) (1,4,7) times column 1 of A (1,4,7) = 14 = 66
<br>

```{r decompose2}

decompose_dot_product(t_a,a)

```



<br>


## Commutativity when A is Symmetric


<br>

We previously saw commutativity of A and T(A) is only assured if the columns of operand 2 equal the rows of operand 1

<br>

By definition, a symmetric matrix is identical to its transpose and thus in that case, the dot product is commutative

<br>

Here we create the following matrix.

$$\begin{bmatrix} 	4&6&2\\ 6&0&5\\ 2&5&0		\end{bmatrix}$$

```{r}

a<-matrix(c(4,6,2,6,0,5,2,5,0), byrow = TRUE, ncol = 3)
t_a<-t(a)  

```



<br>

Its clear the rows match the columns. Now pass A and its transpose to the decomposition function. Do it again, flipping the operands.

<br>


```{r}

decompose_dot_product(a, t_a)

decompose_dot_product(t_a,a)


```



<br>

## LU Factorization

<br>

An LU Matrix refers to the factorization of a matrix into an <b><i>upper triangular</i></b> and <b><i>lower triangular</i></b> matrix.

<br>

$$A \ = \ L \ \cdot \ U$$
<br>

<b>Upper Triangular</b>
<p class="tab">All numbers below the diagonal are zero</p>
<br>

<b>Lower Triangular</b>
<p class="tab">All numbers below the diagonal are zero</p>



<br>
There are several algorithms to perform LU or LDU ( seperating the diagonal component ) factorization.
<br>
And there are several functions in R. 

This homework translated the VBA submission to the rosettacode challenge to code different algorithms in different languages.
<br>
The original code is found [here](https://rosettacode.org/wiki/LU_decomposition#VBA)

<br>
My translated function is below.

<br>

```{r lu_decomposition}

# returns a permutation function to flip rows
pivotize<-function(A) {
  
  l<-length(A)
  n = dim(A)[1]

  # create an identity matrix 
  im<-diag(n)
  
  for (i in (1:n)) {
    mx<-abs(A[i,i])        # the diagonal value
    row_<-i
    
        for (j in (i:n)) {      # loop from diag point to the end
          if (abs(A[j,i]) > mx) {
            mx<-abs(A[j,i])     # save off the new max
            row_<-j
          }
          }  # end of j loop 1
     
      for (j in 1:n) {
        tmp<-im[i,j]
        im[i,j]<-im[row_,j]
        im[row_,j]<-tmp
      }  # end of j loop 2
        
  }  # end of i loop 

  return (im)
}

lu<-function(A) {
  
  l<-length(A)
  n = dim(A)[1]
  
  
  L<-matrix(rep(0,l), byrow = TRUE, ncol = n)
  U<-matrix(rep(0,l), byrow = TRUE, ncol = n)
  
  # this returns a permutation matrix that flips rows
  P<-pivotize(A)
  
  A2<-P %*% A

  
  for ( j in 1:n) {
    L[j, j] = 1
    
    
    
    for ( i in 1:j) {
      sum1<-0
      
      for (k in 1:i) {
        sum1<-sum1 + U[k,j] * L[i,k]
      }
      
      U[i,j]<-A2[i,j] - sum1
      
    } # end of i loop

   
    # we only want to iterate betwen j+1 up to n-1
    # VBA is different than R, so this could be cleaned up
    jplus<-j+1
    if (jplus > n) {
      jplus<-n
    }

    for ( i in jplus:n) {
      sum2<-0
      for (k in 1:j) {
        sum2<-sum2 + U[k,j] * L[i,k]
      
      }

      if(i != j) {
        L[i,j]<- (A2[i,j]-sum2) / U[j,j]
      }

    } # end of second i loop
    
    
  } # end of j loop
  
  
  
  cat("Lower ")
  prmatrix(round(L,2), rowlab=rep("",3), collab=rep("",3))
  
  cat("\n\nUpper \n")
  prmatrix(round(U,2), rowlab=rep("",3), collab=rep("",3))
  

  cat("\n\nPermutation \n")
  prmatrix(P, rowlab=rep("",3), collab=rep("",3))
  
  cat("\n\nPermutation %*% Lower %*% Upper \n")
  prmatrix(P %*% L %*% U, rowlab=rep("",3), collab=rep("",3))

  
}


```

<br>

Invoke the function for the following :

<br>

$$\begin{bmatrix} 	1&2&3\\ 7&8&9\\ 4&5&6		\end{bmatrix}$$

<br>

```{r}

A<-matrix(c(1,2,3, 7,8,9, 4,5,6), byrow = TRUE, ncol = 3)
B<-lu(A)

```

<br>

## Other Factorization Methods

<br>

The Matrix and matrixcalc packages offer lu.decomposition(), qr(), and chol()

<br>

Another way is to manually employ Gausian Elimination to "zero out the elements" below the diagonal, creating an Upper Triangular Matrix.

<br> 

Those row operations, which zero out the elements, combine into a single matrix that is now the inverse of the Lower Triangular Matrix, i.e.

$$L^{-1} \ \cdot \ A \ = \ U$$
where your row operations represent $L^{-1}$

<br> 

An excellent tutorial on the manual method can be found [here](https://www.youtube.com/watch?v=HS7RadfcoFk)

